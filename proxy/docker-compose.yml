services:
  certbot:
    image: certbot/certbot
    container_name: proxy-certbot
    network_mode: "host"
    restart: unless-stopped
    environment:
      - DOMAIN=goggregator-test.unicity.network
      - ADDITIONAL_DOMAINS=faucet.unicity.network
      - EMAIL=${CERTBOT_EMAIL:-admin@unicity.network}
    volumes:
      - letsencrypt_certs:/etc/letsencrypt
      - acme_webroot:/var/www/certbot
    healthcheck:
      test: ["CMD-SHELL", "test -f /etc/letsencrypt/live/goggregator-test.unicity.network/haproxy.pem && test -f /etc/letsencrypt/ssl-dhparams.pem"]
      interval: 5s
      timeout: 5s
      retries: 120
      start_period: 60s
    entrypoint: >
      sh -c "
        set -e;
        DOMAIN=\"$${DOMAIN:-goggregator-test.unicity.network}\";
        ADDITIONAL_DOMAINS=\"$${ADDITIONAL_DOMAINS:-}\";
        EMAIL=\"$${EMAIL:-admin@unicity.network}\";
        LE_PATH=\"/etc/letsencrypt/live/$$DOMAIN\";
        WEBROOT=\"/var/www/certbot\";

        echo '=== Certbot Auto-Configuration Starting ===';

        # Check if certificate already exists
        if [ ! -f \"$$LE_PATH/fullchain.pem\" ]; then
          echo 'No existing certificate found. Obtaining new certificate...';
          echo \"Email: $$EMAIL\";
          echo \"Primary domain: $$DOMAIN\";

          # Build domain list
          DOMAIN_ARGS=\"--domain $$DOMAIN\";
          if [ -n \"$$ADDITIONAL_DOMAINS\" ]; then
            echo \"Additional domains: $$ADDITIONAL_DOMAINS\";
            for additional in $$(echo \"$$ADDITIONAL_DOMAINS\" | tr ',' ' '); do
              DOMAIN_ARGS=\"$$DOMAIN_ARGS --domain $$additional\";
            done;
          fi;

          # Obtain initial certificate using standalone mode
          # (port 80 is available since HAProxy hasn't started yet)
          certbot certonly --authenticator standalone --preferred-challenges http --non-interactive --agree-tos --email \"$$EMAIL\" --no-eff-email $$DOMAIN_ARGS || {
            echo 'ERROR: Failed to obtain certificate. Check DNS and network connectivity.';
            exit 1;
          };

          echo 'Certificate obtained successfully!';
        else
          echo 'Existing certificate found. Skipping initial acquisition.';
        fi;

        # Generate DH parameters if they don't exist
        if [ ! -f /etc/letsencrypt/ssl-dhparams.pem ]; then
          echo 'Generating DH parameters (this may take a few minutes)...';
          openssl dhparam -out /etc/letsencrypt/ssl-dhparams.pem 2048;
          echo 'DH parameters generated.';
        else
          echo 'DH parameters already exist.';
        fi;

        # Create HAProxy-compatible certificate file
        echo 'Creating HAProxy certificate bundle...';
        cat \"$$LE_PATH/privkey.pem\" \"$$LE_PATH/fullchain.pem\" > \"$$LE_PATH/haproxy.pem\";
        chmod -R 755 /etc/letsencrypt/live;
        chmod -R 755 /etc/letsencrypt/archive;
        echo 'HAProxy certificate bundle created.';

        echo '=== Initial setup complete. Service is healthy. ===';

        # Wait a moment for HAProxy to start
        sleep 5;

        # Main renewal loop
        echo 'Starting renewal loop (checks every 12 hours)...';
        while :; do
          echo \"[$(date)] Running renewal check...\";

          certbot renew --webroot --webroot-path=\"$$WEBROOT\" --deploy-hook \"cat $$LE_PATH/privkey.pem $$LE_PATH/fullchain.pem > $$LE_PATH/haproxy.pem && chmod -R 755 /etc/letsencrypt/live && chmod -R 755 /etc/letsencrypt/archive && kill -SIGUSR2 1\" 2>&1 || echo 'Renewal check completed (no renewal needed or failed).';

          echo \"[$(date)] Next check in 12 hours.\";
          sleep 12h & wait $${!};
        done;
      "

  haproxy:
    image: haproxy:2.8
    container_name: proxy-haproxy
    network_mode: "host"
    restart: unless-stopped
    user: root
    depends_on:
      certbot:
        condition: service_healthy
    environment:
      # Password hash for admin user (used for /logs endpoint)
      # Generate with: ./proxy/generate-password-hash.sh 'yourpassword'
      # Add to .env: DOZZLE_PASSWORD_HASH=$$6$$salt$$hash (note: $$ escapes $ in .env)
      - DOZZLE_PASSWORD_HASH=${DOZZLE_PASSWORD_HASH:-}
    volumes:
      - ./haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro
      - ./haproxy/docker-entrypoint.sh:/docker-entrypoint.sh:ro
      - letsencrypt_certs:/etc/letsencrypt:ro
    entrypoint: ["/bin/sh", "/docker-entrypoint.sh"]

  # Nginx serves ACME challenge files for certbot renewals
  nginx-acme:
    image: nginx:alpine
    container_name: proxy-nginx-acme
    network_mode: "host"
    restart: unless-stopped
    depends_on:
      certbot:
        condition: service_healthy
    volumes:
      - acme_webroot:/usr/share/nginx/html:ro
    command: >
      sh -c "
        echo 'server {
          listen 8080;
          server_name _;
          location /.well-known/acme-challenge/ {
            root /usr/share/nginx/html;
          }
        }' > /etc/nginx/conf.d/default.conf &&
        nginx -g 'daemon off;'
      "

volumes:
  letsencrypt_certs:
  acme_webroot:
